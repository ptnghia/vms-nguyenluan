# üöÄ ƒê·ªÅ Xu·∫•t T·ªëi ∆Øu Dual-Quality Recording

**Ng√†y:** 20 Th√°ng 10, 2025  
**V·∫•n ƒë·ªÅ:** CPU usage cao (126% per camera) do dual-quality transcoding  
**M·ª•c ti√™u:** Gi·∫£m xu·ªëng <50% CPU per camera

---

## üìä PH√ÇN T√çCH V·∫§N ƒê·ªÄ HI·ªÜN T·∫†I

### **Ki·∫øn tr√∫c hi·ªán t·∫°i:**

```
Camera RTSP Stream (1080p @ 4Mbps)
    ‚îÇ
    ‚îú‚îÄ> FFmpeg Process 1: Recording (copy mode)
    ‚îÇ   ‚îî‚îÄ> Output: 1440p @ 5Mbps (0% CPU - copy codec)
    ‚îÇ
    ‚îú‚îÄ> FFmpeg Process 2: Live Transcode LOW
    ‚îÇ   ‚îî‚îÄ> NVENC: 1080p ‚Üí 720p @ 2Mbps (~63% CPU)
    ‚îÇ
    ‚îî‚îÄ> FFmpeg Process 3: Live Transcode HIGH
        ‚îî‚îÄ> NVENC: 1080p ‚Üí 1440p @ 5Mbps (~63% CPU)

Total CPU per camera: 0% + 63% + 63% = 126% CPU
```

### **V·∫•n ƒë·ªÅ:**

1. **3 FFmpeg processes** cho m·ªói camera (1 recording + 2 transcoding)
2. **2 RTSP connections** t·ªõi camera (recording + transcoding ƒë·ªçc ri√™ng)
3. **NVENC overhead:** M·ªói transcode process = ~63% CPU
4. **Kh√¥ng t·∫≠n d·ª•ng Intel QuickSync** (QSV) - hi·ªáu qu·∫£ h∆°n NVENC cho nhi·ªÅu streams

### **T√†i nguy√™n hi·ªán t·∫°i (2 cameras):**

```yaml
CPU: 252% (2.5 cores) cho 2 cameras
  ‚Üí 126% per camera
  ‚Üí V·ªõi 5 cameras: 630% (6.3 cores) ‚ùå KH√îNG B·ªÄN V·ªÆNG

GPU: 5% NVENC (hi·ªáu qu·∫£ nh∆∞ng kh√¥ng c·∫ßn thi·∫øt)
RAM: 4.5GB (2.25GB per camera)
```

---

## üí° GI·∫¢I PH√ÅP ƒê·ªÄ XU·∫§T

### **üéØ Gi·∫£i ph√°p 1: SINGLE FFMPEG PROCESS v·ªõi Multi-Output (KHUY·∫æN NGH·ªä)**

#### **Ki·∫øn tr√∫c m·ªõi:**

```
Camera RTSP Stream (1080p @ 4Mbps)
    ‚îÇ
    ‚îî‚îÄ> Single FFmpeg Process v·ªõi 3 outputs:
        ‚îÇ
        ‚îú‚îÄ> Output 1: Recording (copy mode, 0% CPU)
        ‚îÇ   ‚îî‚îÄ> 1440p @ 5Mbps MP4 segments
        ‚îÇ
        ‚îú‚îÄ> Output 2: Live LOW (NVENC/QSV, ~30% CPU)
        ‚îÇ   ‚îî‚îÄ> 720p @ 2Mbps ‚Üí MediaMTX
        ‚îÇ
        ‚îî‚îÄ> Output 3: Live HIGH (NVENC/QSV, ~30% CPU)
            ‚îî‚îÄ> 1440p @ 5Mbps ‚Üí MediaMTX

Total CPU per camera: 0% + 30% + 30% = 60% CPU
Gi·∫£m: 126% ‚Üí 60% = 52% reduction ‚úÖ
```

#### **L·ª£i √≠ch:**

1. ‚úÖ **Single RTSP connection** - Gi·∫£m load tr√™n camera
2. ‚úÖ **Shared input decode** - Decode 1 l·∫ßn, d√πng cho 3 outputs
3. ‚úÖ **Gi·∫£m 50% CPU** - 126% ‚Üí 60% per camera
4. ‚úÖ **ƒê∆°n gi·∫£n h∆°n** - 1 process thay v√¨ 3
5. ‚úÖ **√çt memory** - Shared buffers

#### **FFmpeg Command:**

```bash
ffmpeg \
  -rtsp_transport tcp \
  -i "$RTSP_URL" \
  \
  # Output 1: Recording (copy mode - 0% CPU)
  -map 0 -c copy \
  -f segment -segment_time 180 -segment_format mp4 \
  -strftime 1 -reset_timestamps 1 \
  "/data/recordings/${CAMERA_NAME}/%Y%m%d_%H%M%S.mp4" \
  \
  # Output 2: Live LOW 720p (NVENC - ~30% CPU)
  -map 0:v -c:v h264_nvenc \
  -s 1280x720 -b:v 2M -maxrate 2M -bufsize 4M \
  -preset p4 -tune ll -r 25 -g 50 \
  -f rtsp "rtsp://localhost:8554/live/${CAMERA_ID}/low" \
  \
  # Output 3: Live HIGH 1440p (NVENC - ~30% CPU)
  -map 0:v -c:v h264_nvenc \
  -s 2560x1440 -b:v 5M -maxrate 5M -bufsize 10M \
  -preset p4 -tune ll -r 25 -g 50 \
  -f rtsp "rtsp://localhost:8554/live/${CAMERA_ID}/high"
```

#### **∆Ø·ªõc t√≠nh performance:**

```yaml
Per Camera:
  CPU: 60% (0.6 cores)
  RAM: 1.5GB (gi·∫£m 33%)
  GPU: 3% NVENC
  
5 Cameras:
  CPU: 300% (3 cores) vs 630% hi·ªán t·∫°i
  RAM: 7.5GB vs 11.25GB hi·ªán t·∫°i
  GPU: 15% vs 25% hi·ªán t·∫°i
  
Headroom:
  CPU: 11 cores free (78% free) ‚úÖ
  RAM: 8.5GB free ‚úÖ
  GPU: 85% free ‚úÖ
```

---

### **üéØ Gi·∫£i ph√°p 2: INTEL QUICKSYNC (QSV) thay v√¨ NVENC (T·ªêI ∆ØU NH·∫§T)**

#### **T·∫°i sao QSV t·ªët h∆°n NVENC cho use case n√†y:**

```yaml
NVENC (NVIDIA GPU):
  Pros:
    - Ch·∫•t l∆∞·ª£ng t·ªët
    - Latency th·∫•p
  Cons:
    - Gi·ªõi h·∫°n concurrent encodes (~3-5 streams)
    - C·∫ßn GPU ri√™ng
    - Power consumption cao
    
Intel QuickSync (QSV):
  Pros:
    - Integrated trong CPU (i5-14500 c√≥ QSV Gen 12.5)
    - Support 30-40 concurrent encodes
    - Power efficient
    - Kh√¥ng c·∫ßn GPU ri√™ng
    - Ch·∫•t l∆∞·ª£ng t·ªët (H.264/H.265)
  Cons:
    - Ch·∫•t l∆∞·ª£ng h∆°i k√©m NVENC (~5%)
    - C·∫ßn driver ƒë√∫ng
```

#### **FFmpeg Command v·ªõi QSV:**

```bash
ffmpeg \
  -hwaccel qsv -c:v h264_qsv \
  -rtsp_transport tcp \
  -i "$RTSP_URL" \
  \
  # Output 1: Recording (copy mode)
  -map 0 -c copy \
  -f segment -segment_time 180 -segment_format mp4 \
  -strftime 1 -reset_timestamps 1 \
  "/data/recordings/${CAMERA_NAME}/%Y%m%d_%H%M%S.mp4" \
  \
  # Output 2: Live LOW 720p (QSV - ~15% CPU)
  -map 0:v -c:v h264_qsv \
  -s 1280x720 -b:v 2M -maxrate 2M -bufsize 4M \
  -preset veryfast -g 50 -r 25 \
  -f rtsp "rtsp://localhost:8554/live/${CAMERA_ID}/low" \
  \
  # Output 3: Live HIGH 1440p (QSV - ~15% CPU)
  -map 0:v -c:v h264_qsv \
  -s 2560x1440 -b:v 5M -maxrate 5M -bufsize 10M \
  -preset veryfast -g 50 -r 25 \
  -f rtsp "rtsp://localhost:8554/live/${CAMERA_ID}/high"
```

#### **∆Ø·ªõc t√≠nh performance v·ªõi QSV:**

```yaml
Per Camera:
  CPU: 30% (0.3 cores) - Gi·∫£m 76%!
  RAM: 1.2GB
  GPU: 0% (kh√¥ng d√πng NVENC)
  
5 Cameras:
  CPU: 150% (1.5 cores) ‚úÖ EXCELLENT!
  RAM: 6GB
  GPU: 0%
  
Headroom:
  CPU: 12.5 cores free (89% free) ‚úÖ‚úÖ
  RAM: 10GB free ‚úÖ
  GPU: 100% free (d√†nh cho AI Phase 3) ‚úÖ
```

---

### **üéØ Gi·∫£i ph√°p 3: ON-DEMAND TRANSCODING (T·ªëi ∆∞u nh·∫•t cho production)**

#### **Concept:**

```
Recording: Lu√¥n ch·∫°y (copy mode, 0% CPU)
Live Transcoding: Ch·ªâ ch·∫°y khi c√≥ viewer

Flow:
1. Client request live stream ‚Üí API check viewers
2. N·∫øu viewers = 0 ‚Üí Start transcoding process
3. N·∫øu viewers > 0 ‚Üí Reuse existing stream
4. Khi viewers = 0 (timeout 30s) ‚Üí Stop transcoding

Benefits:
- Kh√¥ng transcode khi kh√¥ng c·∫ßn
- Ti·∫øt ki·ªám 100% CPU khi kh√¥ng c√≥ viewer
- Scale t·ªët v·ªõi nhi·ªÅu cameras
```

#### **Ki·∫øn tr√∫c:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Camera 1-5: Recording ONLY (copy mode)          ‚îÇ
‚îÇ CPU: 0% √ó 5 = 0%                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚îÇ Khi c√≥ viewer request
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ On-Demand Transcoder (QSV)                      ‚îÇ
‚îÇ - Start khi viewer connect                      ‚îÇ
‚îÇ - Stop sau 30s kh√¥ng c√≥ viewer                  ‚îÇ
‚îÇ - CPU: 30% per active camera                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

V√≠ d·ª•:
- 5 cameras recording: 0% CPU
- 2 cameras c√≥ viewers: 60% CPU
- Total: 60% CPU (thay v√¨ 630%)
```

#### **Implementation:**

```typescript
// API endpoint: GET /api/streams/camera/:id
async function getStreamUrl(cameraId: string, quality: string) {
  // Check if transcoding process exists
  const transcoder = transcoderManager.get(cameraId, quality);
  
  if (!transcoder || !transcoder.isRunning()) {
    // Start on-demand transcoding
    await transcoderManager.start(cameraId, quality);
  }
  
  // Update viewer count
  transcoderManager.addViewer(cameraId, quality);
  
  // Return stream URL
  return {
    url: `rtsp://localhost:8554/live/${cameraId}/${quality}`,
    viewers: transcoderManager.getViewerCount(cameraId, quality)
  };
}

// Cleanup idle transcoders (run every 30s)
setInterval(() => {
  transcoderManager.cleanupIdle(30); // Stop if no viewers for 30s
}, 30000);
```

---

## üìä SO S√ÅNH C√ÅC GI·∫¢I PH√ÅP

| Gi·∫£i ph√°p | CPU/cam | RAM/cam | GPU | Complexity | Khuy·∫øn ngh·ªã |
|-----------|---------|---------|-----|------------|-------------|
| **Hi·ªán t·∫°i** | 126% | 2.25GB | 5% | Medium | ‚ùå Kh√¥ng b·ªÅn v·ªØng |
| **1. Single FFmpeg + NVENC** | 60% | 1.5GB | 3% | Low | ‚úÖ T·ªët |
| **2. Single FFmpeg + QSV** | 30% | 1.2GB | 0% | Low | ‚úÖ‚úÖ R·∫•t t·ªët |
| **3. On-Demand + QSV** | 0-30% | 1.2GB | 0% | High | ‚úÖ‚úÖ‚úÖ T·ªëi ∆∞u nh·∫•t |

### **Khuy·∫øn ngh·ªã theo phase:**

```yaml
Phase 1 MVP (Hi·ªán t·∫°i):
  ‚Üí Gi·∫£i ph√°p 2: Single FFmpeg + QSV
  L√Ω do: ƒê∆°n gi·∫£n, hi·ªáu qu·∫£, ƒë·ªß cho demo
  Timeline: 1 ng√†y implement
  
Phase 2 Production (50 cameras):
  ‚Üí Gi·∫£i ph√°p 3: On-Demand + QSV
  L√Ω do: Scale t·ªët, ti·∫øt ki·ªám t√†i nguy√™n
  Timeline: 1 tu·∫ßn implement
  
Phase 4 Enterprise (200 cameras):
  ‚Üí Gi·∫£i ph√°p 3 + Load Balancing
  L√Ω do: Distribute load across nodes
  Timeline: ƒê√£ c√≥ trong k·∫ø ho·∫°ch
```

---

## üîß IMPLEMENTATION PLAN

### **Phase 1: Quick Fix (1 ng√†y) - KHUY·∫æN NGH·ªä NGAY**

#### **B∆∞·ªõc 1: Verify Intel QSV support**

```bash
# Check QSV availability
ffmpeg -hwaccels | grep qsv

# Test QSV encoding
ffmpeg -hwaccel qsv -c:v h264_qsv \
  -i test.mp4 \
  -c:v h264_qsv -preset veryfast \
  -f null -

# Expected: Should work without errors
```

#### **B∆∞·ªõc 2: Update camera_recorder.hpp**

Thay ƒë·ªïi t·ª´:
```cpp
// OLD: 3 separate processes
ffmpegProcess = new FFmpegProcess(...);
liveTranscoderLow = new LiveTranscoder(...);
liveTranscoderHigh = new LiveTranscoder(...);
```

Sang:
```cpp
// NEW: Single process with multi-output
ffmpegProcess = new FFmpegMultiOutput(...);
// Handles recording + 2 live streams in one process
```

#### **B∆∞·ªõc 3: Create new FFmpegMultiOutput class**

```cpp
// services/recorder/src/ffmpeg_multi_output.hpp
class FFmpegMultiOutput {
private:
    std::string buildCommand() {
        return "ffmpeg "
               "-hwaccel qsv -c:v h264_qsv "
               "-rtsp_transport tcp -i " + rtspUrl + " "
               
               // Recording output (copy)
               "-map 0 -c copy "
               "-f segment -segment_time 180 "
               + recordingPath + " "
               
               // Live LOW (QSV)
               "-map 0:v -c:v h264_qsv "
               "-s 1280x720 -b:v 2M "
               "-f rtsp " + mediamtxUrlLow + " "
               
               // Live HIGH (QSV)
               "-map 0:v -c:v h264_qsv "
               "-s 2560x1440 -b:v 5M "
               "-f rtsp " + mediamtxUrlHigh;
    }
};
```

#### **B∆∞·ªõc 4: Test v·ªõi 1 camera**

```bash
# Stop current recorder
pm2 stop vms-recorder

# Rebuild with new code
cd services/recorder/build
cmake .. && make

# Start and test
pm2 start vms-recorder

# Monitor CPU
htop
# Expected: ~30% CPU per camera (vs 126% hi·ªán t·∫°i)
```

#### **B∆∞·ªõc 5: Rollout to all cameras**

```bash
# If test successful, deploy to all cameras
pm2 restart vms-recorder

# Monitor for 1 hour
pm2 logs vms-recorder --lines 100
```

**Timeline:** 4-6 hours  
**Risk:** Low (c√≥ th·ªÉ rollback n·∫øu c√≥ v·∫•n ƒë·ªÅ)  
**Expected result:** CPU gi·∫£m t·ª´ 126% ‚Üí 30% per camera

---

### **Phase 2: On-Demand Transcoding (1 tu·∫ßn)**

#### **Architecture:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ TranscoderManager (Node.js)              ‚îÇ
‚îÇ - Track active transcoders               ‚îÇ
‚îÇ - Start/stop on demand                   ‚îÇ
‚îÇ - Monitor viewer count                   ‚îÇ
‚îÇ - Cleanup idle transcoders               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ> Spawn FFmpeg process khi c·∫ßn
         ‚îî‚îÄ> Kill FFmpeg process khi idle
```

#### **Implementation files:**

```typescript
// services/api/src/services/transcoder-manager.ts
class TranscoderManager {
  private transcoders: Map<string, Transcoder>;
  
  async start(cameraId: string, quality: string): Promise<void> {
    // Spawn FFmpeg process
  }
  
  async stop(cameraId: string, quality: string): Promise<void> {
    // Kill FFmpeg process
  }
  
  addViewer(cameraId: string, quality: string): void {
    // Increment viewer count
  }
  
  removeViewer(cameraId: string, quality: string): void {
    // Decrement viewer count
    // Schedule cleanup if viewers = 0
  }
  
  cleanupIdle(timeoutSeconds: number): void {
    // Stop transcoders with 0 viewers for > timeout
  }
}
```

**Timeline:** 5-7 days  
**Risk:** Medium (c·∫ßn testing k·ªπ)  
**Expected result:** CPU = 0% khi kh√¥ng c√≥ viewers

---

## üìà EXPECTED RESULTS

### **Sau khi implement Gi·∫£i ph√°p 2 (Single FFmpeg + QSV):**

```yaml
Current (2 cameras):
  CPU: 252% (2.5 cores)
  RAM: 4.5GB
  GPU: 5%

After Optimization (2 cameras):
  CPU: 60% (0.6 cores) ‚úÖ 76% reduction
  RAM: 2.4GB ‚úÖ 47% reduction
  GPU: 0% ‚úÖ Free for AI

Scaling to 5 cameras:
  Current: 630% (6.3 cores) ‚ùå Not sustainable
  After: 150% (1.5 cores) ‚úÖ Sustainable!
  
Headroom:
  CPU: 12.5 cores free (89%)
  RAM: 13.6GB free (85%)
  GPU: 100% free for Phase 3 AI
```

### **Sau khi implement Gi·∫£i ph√°p 3 (On-Demand):**

```yaml
5 cameras, 2 c√≥ viewers:
  Recording: 0% CPU (5 cameras)
  Transcoding: 60% CPU (2 cameras)
  Total: 60% CPU ‚úÖ
  
5 cameras, 0 viewers (night time):
  Recording: 0% CPU
  Transcoding: 0% CPU
  Total: 0% CPU ‚úÖ‚úÖ
  
Average (assume 40% viewing time):
  CPU: 60% √ó 0.4 = 24% average ‚úÖ‚úÖ‚úÖ
```

---

## ‚úÖ KHUY·∫æN NGH·ªä H√ÄNH ƒê·ªòNG

### **Ngay l·∫≠p t·ª©c (H√¥m nay):**

1. ‚úÖ **Verify Intel QSV support** (30 ph√∫t)
2. ‚úÖ **Implement Single FFmpeg + QSV** (4 hours)
3. ‚úÖ **Test v·ªõi 1 camera** (1 hour)
4. ‚úÖ **Deploy to all cameras** (1 hour)

**Total:** 6-7 hours  
**Expected:** CPU gi·∫£m 76% (126% ‚Üí 30% per camera)

### **Tu·∫ßn t·ªõi (Phase 2 prep):**

1. üîÑ **Design On-Demand architecture** (1 day)
2. üîÑ **Implement TranscoderManager** (2 days)
3. üîÑ **Testing & validation** (2 days)

**Total:** 5 days  
**Expected:** CPU = 0% khi kh√¥ng c√≥ viewers

---

## üéØ K·∫æT LU·∫¨N

**V·∫•n ƒë·ªÅ:** CPU usage 126% per camera kh√¥ng b·ªÅn v·ªØng cho 5+ cameras

**Gi·∫£i ph√°p ng·∫Øn h·∫°n:** Single FFmpeg + Intel QSV
- ‚úÖ Gi·∫£m 76% CPU (126% ‚Üí 30%)
- ‚úÖ Implement trong 1 ng√†y
- ‚úÖ Low risk, c√≥ th·ªÉ rollback

**Gi·∫£i ph√°p d√†i h·∫°n:** On-Demand Transcoding
- ‚úÖ Gi·∫£m 100% CPU khi kh√¥ng c√≥ viewers
- ‚úÖ Scale t·ªët cho 200 cameras
- ‚úÖ Production-ready

**Timeline:**
- H√¥m nay: Implement Gi·∫£i ph√°p 2 (6 hours)
- Tu·∫ßn t·ªõi: Implement Gi·∫£i ph√°p 3 (5 days)

**∆Øu ti√™n:** üî¥ **CAO** - C·∫ßn l√†m tr∆∞·ªõc khi scale l√™n 5 cameras

---

**Ng∆∞·ªùi ƒë·ªÅ xu·∫•t:** AI Assistant  
**Ng√†y:** 20 Th√°ng 10, 2025  
**Status:** Ch·ªù ph√™ duy·ªát & implement

